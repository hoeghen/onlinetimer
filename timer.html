<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Online Stopwatch & Timer PWA - Digital Countdown & Time Tracking</title>
    
    <!-- PWA Meta Tags -->
    <meta name="theme-color" content="#1a202c"/>
    
    <!-- Embedded Manifest JSON (Base64 encoded) -->
    <link rel="manifest" href="data:application/json;base64,eyJuYW1lIjoiQ29tcGFjdCBTdG9wd2F0Y2ggJiBUaW1lciIsInNob3J0X25hbWUiOiJUaW1lckFwcCIsImRlc2NyaXB0aW9uIjoiQSBjb21wYWN0IGFuZCByZXNwb25zaXZlIHN0b3B3YXRjaCBhbmQgY291bnRkb3duIHRpbWVyIFBXQS4iLCJzdGFydF91cmwiOiIuL2luZGV4Lmh0bWwiLCJkaXNwbGF5Ijoic3RhbmRhbG9uZSIsImJhY2tncm91bmRfY29sb3IiOiIjMWEyMDJjIiwidGhlbWVfY29sb3IiOiIjMWEyMDJjIiwiaWNvbnMiOlt7InNyYyI6Ii9pY29ucy9pY29uLTE5MngxOTIucG5nIiwic2l6ZXMiOiIxOTJ4MTkyIiwidHlwZSI6ImltYWdlL3BuZyJ9LHsic3JjIjoiL2ljb25zL2ljb24tNTEyeDUxMi5wbmciLCJzaXplcyI6IjUxMnU1MTIiLCJ0eXBlIjoiaW1hZ2UvcG5nIn0seyJzcmMiOiIvaWNvbnMvZmF2aWNvbi5pY28iLCJzaXplcyI6IjQ4eDQ4IiwidHlwZSI6ImltYWdlL3gtY29uIn1dfQ==">
    
    <link rel="apple-touch-icon" href="/icons/icon-192x192.png">

    <!-- Favicon (optional, but good practice) -->
    <link rel="icon" href="/icons/favicon.ico" type="image/x-icon">

    <!-- SEO Meta Tags -->
    <meta name="description" content="A compact, responsive online stopwatch and digital countdown timer PWA with millisecond accuracy. Track time, set alarms, and manage tasks efficiently.">
    <meta name="keywords" content="online stopwatch, online timer, countdown timer, digital timer, time tracker, PWA, responsive timer, compact timer, free timer, alarm clock, web timer, millisecond timer">
    <meta name="author" content="Your Name or Company Name">

    <!-- hreflang tags for international SEO -->
    <!-- Use x-default for the primary version, and specific languages if you translate the content -->
    <link rel="alternate" hreflang="x-default" href="https://your-app-url.com/">
    <link rel="alternate" hreflang="en" href="https://your-app-url.com/">
    <link rel="alternate" hreflang="es" href="https://your-app-url.com/?lang=es"> <!-- Example for Spanish version -->
    <link rel="alternate" hreflang="fr" href="https://your-app-url.com/?lang=fr"> <!-- Example for French version -->
    <link rel="alternate" hreflang="de" href="https://your-app-url.com/?lang=de"> <!-- Example for German version -->
    <link rel="alternate" hreflang="zh" href="https://your-app-url.com/?lang=zh"> <!-- Example for Chinese version -->
    <link rel="alternate" hreflang="ja" href="https://your-app-url.com/?lang=ja"> <!-- Example for Japanese version -->


    <!-- Open Graph / Facebook / LinkedIn -->
    <meta property="og:type" content="website">
    <meta property="og:url" content="https://your-app-url.com/"> <!-- Replace with your actual app URL -->
    <meta property="og:title" content="Online Stopwatch & Timer PWA - Digital Countdown & Time Tracking">
    <meta property="og:description" content="A compact, responsive online stopwatch and digital countdown timer PWA with millisecond accuracy. Track time, set alarms, and manage tasks efficiently.">
    <meta property="og:image" content="https://your-app-url.com/icons/icon-512x512.png"> <!-- Replace with your actual app URL for a preview image -->

    <!-- Twitter -->
    <meta property="twitter:card" content="summary_large_image">
    <meta property="twitter:url" content="https://your-app-url.com/"> <!-- Replace with your actual app URL -->
    <meta property="twitter:title" content="Online Stopwatch & Timer PWA - Digital Countdown & Time Tracking">
    <meta property="twitter:description" content="A compact, responsive online stopwatch and digital countdown timer PWA with millisecond accuracy. Track time, set alarms, and manage tasks efficiently.">
    <meta property="twitter:image" content="https://your-app-url.com/icons/icon-512x512.png"> <!-- Replace with your actual app URL for a preview image -->

    <!-- Schema.org Structured Data -->
    <script type="application/ld+json">
    {
      "@context": "http://schema.org",
      "@type": "WebApplication",
      "name": "Online Stopwatch & Timer",
      "applicationCategory": "Utilities",
      "operatingSystem": "Any (Web-based)",
      "url": "https://your-app-url.com/", <!-- Replace with your actual app URL -->
      "description": "A compact, responsive online stopwatch and digital countdown timer PWA with millisecond accuracy. Track time, set alarms, and manage tasks efficiently.",
      "softwareRequirements": "Web browser",
      "featureList": [
        "Online Stopwatch with millisecond accuracy and lap function",
        "Online Countdown Timer with millisecond accuracy and mouse-adjustable settings",
        "Responsive design for all screen sizes (down to 200px)",
        "Progressive Web App (PWA) capabilities for offline use (requires separate service worker file)",
        "Digital time display with clear numbers",
        "Audible alarm for timer completion"
      ],
      "screenshot": "https://your-app-url.com/icons/icon-512x512.png", <!-- Replace with a screenshot of your app -->
      "aggregateRating": {
        "@type": "AggregateRating",
        "ratingValue": "5.0",
        "reviewCount": "1"
      },
      "offers": {
        "@type": "Offer",
        "price": "0",
        "priceCurrency": "USD"
      }
    }
    </script>

    <!-- Tailwind CSS CDN -->
    <script src="https://cdn.tailwindcss.com"></script>

    <!-- Google Fonts - Inter -->
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&family=Roboto+Mono:wght@400;700&display=swap" rel="stylesheet">

    <!-- React and ReactDOM CDNs -->
    <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    
    <!-- Babel for JSX transpilation in browser -->
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>

    <style>
        /* Custom styles for font-inter and font-mono */
        body {
            font-family: 'Inter', sans-serif;
        }
        .font-mono {
            font-family: 'Roboto Mono', monospace;
        }
        /* Basic animation for pulse effect */
        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }
        .animate-pulse {
            animation: pulse 1.5s cubic-bezier(0.4, 0, 0.6, 1) infinite;
        }
    </style>
</head>
<body>
    <div id="root"></div>

    <script type="text/babel">
        const { useState, useEffect, useRef } = React;
        const ReactDOM = window.ReactDOM; // Explicitly reference ReactDOM from the global window object

        // Inline SVG Icons (replacing lucide-react for self-contained HTML)
        const IconPlay = ({ size = 18, className = "" }) => (
            <svg xmlns="http://www.w3.org/2000/svg" width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className={className}><polygon points="5 3 19 12 5 21 5 3"/></svg>
        );
        const IconPause = ({ size = 18, className = "" }) => (
            <svg xmlns="http://www.w3.org/2000/svg" width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className={className}><rect x="6" y="4" width="4" height="16"/><rect x="14" y="4" width="4" height="16"/></svg>
        );
        const IconSquare = ({ size = 18, className = "" }) => (
            <svg xmlns="http://www.w3.org/2000/svg" width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className={className}><rect width="18" height="18" x="3" y="3" rx="2"/></svg>
        );
        const IconRotateCcw = ({ size = 18, className = "" }) => (
            <svg xmlns="http://www.w3.org/2000/svg" width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className={className}><path d="M3 12a9 9 0 1 0 9-9 9.75 9.75 0 0 0-6.76 2.75L3 8"/><path d="M3 3v5h5"/></svg>
        );
        const IconClock = ({ size = 18, className = "" }) => (
            <svg xmlns="http://www.w3.org/2000/svg" width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className={className}><circle cx="12" cy="12" r="10"/><polyline points="12 6 12 12 16 14"/></svg>
        );
        const IconTimer = ({ size = 18, className = "" }) => (
            <svg xmlns="http://www.w3.org/2000/svg" width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className={className}><line x1="10" x2="14" y1="2" y2="2"/><line x1="12" x2="12" y1="14" y2="22"/><path d="M12 14.2V22"/><path d="M10 2h4"/><path d="M4.93 4.93l1.41 1.41"/><path d="M2 12h2"/><path d="M4.93 19.07l1.41-1.41"/><path d="M12 22h0"/><path d="M19.07 19.07l-1.41-1.41"/><path d="M22 12h-2"/><path d="M19.07 4.93l-1.41 1.41"/></svg>
        );
        const IconPlus = ({ size = 18, className = "" }) => (
            <svg xmlns="http://www.w3.org/2000/svg" width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className={className}><path d="M12 5v14"/><path d="M5 12h14"/></svg>
        );
        const IconMinus = ({ size = 18, className = "" }) => (
            <svg xmlns="http://www.w3.org/2000/svg" width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className={className}><path d="M5 12h14"/></svg>
        );

        // Stopwatch Component
        const Stopwatch = () => {
          const [time, setTime] = useState(0); // Time in milliseconds
          const [isRunning, setIsRunning] = useState(false);
          const [laps, setLaps] = useState([]);
          const timerRef = useRef(null);

          // Effect to handle the stopwatch interval
          useEffect(() => {
            if (isRunning) {
              timerRef.current = setInterval(() => {
                setTime((prevTime) => prevTime + 10); // Update every 10ms
              }, 10);
            } else {
              clearInterval(timerRef.current);
            }
            // Cleanup function to clear interval on unmount or when isRunning changes to false
            return () => clearInterval(timerRef.current);
          }, [isRunning]);

          // Function to format time into HH:MM:SS.MS
          const formatTime = (milliseconds) => {
            const hours = Math.floor(milliseconds / 3600000);
            const minutes = Math.floor((milliseconds % 3600000) / 60000);
            const seconds = Math.floor((milliseconds % 60000) / 1000);
            const ms = Math.floor((milliseconds % 1000) / 10); // Two digits for milliseconds

            return (
              String(hours).padStart(2, '0') + ':' +
              String(minutes).padStart(2, '0') + ':' +
              String(seconds).padStart(2, '0') + '.' +
              String(ms).padStart(2, '0')
            );
          };

          // Start stopwatch
          const handleStart = () => {
            setIsRunning(true);
          };

          // Stop stopwatch
          const handleStop = () => {
            setIsRunning(false);
          };

          // Reset stopwatch
          const handleReset = () => {
            setIsRunning(false);
            setTime(0);
            setLaps([]);
          };

          // Record a lap
          const handleLap = () => {
            if (isRunning) {
              setLaps((prevLaps) => [...prevLaps, time]);
            }
          };

          return (
            <div className="w-full flex flex-col items-center">
              {/* Time Display */}
              <div className="text-5xl sm:text-6xl font-mono mb-6 text-indigo-400 tracking-tight text-center scale-90 sm:scale-100">
                {formatTime(time)}
              </div>

              {/* Control Buttons */}
              <div className="flex flex-wrap justify-center gap-2 w-full mb-4">
                {!isRunning ? (
                  <button
                    className="flex-1 min-w-[80px] bg-green-600 hover:bg-green-700 text-white py-2 px-3 rounded-lg shadow-md transition-all duration-200 text-sm font-semibold"
                    onClick={handleStart}
                  >
                    <IconPlay className="inline-block mr-1" size={18} />
                    Start
                  </button>
                ) : (
                  <button
                    className="flex-1 min-w-[80px] bg-red-600 hover:bg-red-700 text-white py-2 px-3 rounded-lg shadow-md transition-all duration-200 text-sm font-semibold"
                    onClick={handleStop}
                  >
                    <IconPause className="inline-block mr-1" size={18} />
                    Stop
                  </button>
                )}
                <button
                  className="flex-1 min-w-[80px] bg-blue-600 hover:bg-blue-700 text-white py-2 px-3 rounded-lg shadow-md transition-all duration-200 text-sm font-semibold"
                  onClick={handleReset}
                >
                    <IconRotateCcw className="inline-block mr-1" size={18} />
                    Reset
                </button>
                <button
                  className="flex-1 min-w-[80px] bg-yellow-600 hover:bg-yellow-700 text-white py-2 px-3 rounded-lg shadow-md transition-all duration-200 text-sm font-semibold"
                  onClick={handleLap}
                  disabled={!isRunning}
                >
                    <IconSquare className="inline-block mr-1" size={18} />
                    Lap
                </button>
              </div>

              {/* Laps Display */}
              {laps.length > 0 && (
                <div className="w-full max-h-40 overflow-y-auto bg-gray-700 rounded-lg p-2 shadow-inner">
                  <h3 className="text-lg font-semibold mb-2 text-gray-300">Laps:</h3>
                  <ul className="space-y-1">
                    {laps.map((lapTime, index) => (
                      <li key={index} className="flex justify-between text-gray-200 text-sm font-mono">
                        <span>Lap {index + 1}:</span>
                        <span>{formatTime(lapTime)}</span>
                      </li>
                    ))}
                  </ul>
                </div>
              )}
            </div>
          );
        };

        // Timer Component
        const Timer = () => {
          const [initialTime, setInitialTime] = useState(0);
          const [timeLeft, setTimeLeft] = useState(0);
          const [isRunning, setIsRunning] = useState(false);
          const [timerMinutes, setTimerMinutes] = useState(5); // Separate state for minutes
          const [timerSeconds, setTimerSeconds] = useState(0); // Separate state for seconds
          const [timerFinished, setTimerFinished] = useState(false);

          const timerRef = useRef(null);
          const audioRef = useRef(null); // This ref is not used for Web Audio API, but kept for consistency if an <audio> tag was used.

          // Effect to handle the timer countdown
          useEffect(() => {
            if (isRunning && timeLeft > 0) {
              timerRef.current = setInterval(() => {
                setTimeLeft((prev) => {
                  if (prev <= 10) { // Check if time is almost zero (within one interval step)
                    setIsRunning(false);
                    setTimerFinished(true);
                    playAlarm();
                    clearInterval(timerRef.current); // Clear interval immediately when timer finishes
                    return 0; // Ensure it displays 00:00.00
                  }
                  return prev - 10;
                });
              }, 10); // Update every 10ms for millisecond accuracy
            } else {
              clearInterval(timerRef.current);
            }
            // Cleanup function
            return () => clearInterval(timerRef.current);
          }, [isRunning, timeLeft]);

          // Function to format time into MM:SS.MS
          const formatTime = (milliseconds) => {
            const totalMs = Math.floor(milliseconds);
            const minutes = Math.floor(totalMs / 60000);
            const seconds = Math.floor((totalMs % 60000) / 1000);
            const centiseconds = Math.floor((totalMs % 1000) / 10); // Two digits for milliseconds

            return `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}.${centiseconds.toString().padStart(2, '0')}`;
          };

          // Format time display for timer setup (when not running)
          const formatTimerDisplay = () => {
            if (isRunning || timeLeft > 0) { // If running or has a remaining time from a previous run
              return formatTime(timeLeft);
            }
            // When not running and timerTime is 0, display based on set minutes/seconds
            return `${timerMinutes.toString().padStart(2, '0')}:${timerSeconds.toString().padStart(2, '0')}.00`;
          };

          // Helper function to update time, ensuring it stays within bounds and is a multiple of 10ms
          const updateTime = (newMinutes, newSeconds) => {
            const totalMs = (newMinutes * 60 + newSeconds) * 1000;
            const clampedTime = Math.max(0, Math.min(totalMs, 59 * 60 * 1000 + 59 * 1000 + 990)); // Max 59:59.99
            
            setTimerMinutes(Math.floor(clampedTime / 60000));
            setTimerSeconds(Math.floor((clampedTime % 60000) / 1000));
            setInitialTime(clampedTime); // Set initial time for reset
            setTimeLeft(clampedTime); // Update time left immediately
            setIsRunning(false); // Stop if running when time is adjusted
            setTimerFinished(false); // Reset finished state
          };

          const adjustTimerMinutes = (delta) => {
            if (!isRunning) {
              const newMinutes = Math.max(0, Math.min(59, timerMinutes + delta));
              updateTime(newMinutes, timerSeconds);
            }
          };

          const adjustTimerSeconds = (delta) => {
            if (!isRunning) {
              const newSeconds = Math.max(0, Math.min(59, timerSeconds + delta));
              updateTime(timerMinutes, newSeconds);
            }
          };

          // Start timer
          const handleStart = () => {
            if (timeLeft === 0 && (timerMinutes > 0 || timerSeconds > 0)) {
                // If timer was reset or never started, set timeLeft from minutes/seconds
                setTimeLeft((timerMinutes * 60 + timerSeconds) * 1000);
                setInitialTime((timerMinutes * 60 + timerSeconds) * 1000); // Also set initial for reset
            }
            if (timeLeft > 0 || (timerMinutes > 0 || timerSeconds > 0)) { // Ensure there's time to start
              setIsRunning(true);
              setTimerFinished(false);
            }
          };

          // Pause timer
          const handlePause = () => {
            setIsRunning(false);
          };

          // Reset timer
          const handleReset = () => {
            setIsRunning(false);
            setTimeLeft(initialTime); // Reset to the initially set time
            setTimerFinished(false);
            if (timerRef.current) {
              clearInterval(timerRef.current);
            }
            // Stop and rewind alarm if it was playing
            // The Web Audio API alarm doesn't need explicit stopping/rewinding like an <audio> tag
          };

          const playAlarm = () => {
            const audioContext = new (window.AudioContext || window.webkitAudioContext)();
            const oscillator = audioContext.createOscillator();
            const gainNode = audioContext.createGain();
            
            oscillator.connect(gainNode);
            gainNode.connect(audioContext.destination);
            
            oscillator.frequency.value = 800;
            oscillator.type = 'sine';
            
            gainNode.gain.setValueAtTime(0.3, audioContext.currentTime);
            gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 1);
            
            oscillator.start(audioContext.currentTime);
            oscillator.stop(audioContext.currentTime + 1);
          };

          return (
            <div className="w-full flex flex-col items-center">
              {/* Time Display */}
              {/* Increased font size and adjusted clamp for better visibility */}
              <div className={`font-mono font-bold tracking-tight ${
                timerFinished ? 'text-red-400 animate-pulse' : 'text-indigo-400'
              }`} style={{ fontSize: 'clamp(2.5rem, 8vw, 4rem)', marginBottom: 'clamp(0.5rem, 2vw, 1rem)' }}>
                {formatTimerDisplay()}
              </div>

              {!isRunning && !timerFinished && ( // Only show adjusters when timer is not running and not finished
                <div className="flex justify-center items-center gap-0.5 mb-4"> {/* Reduced overall gap to gap-0.5 */}
                  {/* Minutes Adjusters */}
                  <div className="flex flex-col items-center">
                    <div className="text-xs font-medium text-gray-300 mb-0.5">Min</div>
                    <div className="flex items-center gap-0.5"> {/* Gap for buttons and number */}
                      <button
                        onClick={() => adjustTimerMinutes(-1)}
                        className="bg-gray-700 hover:bg-gray-600 text-white py-0.5 px-1 rounded-sm shadow-md transition-colors duration-200 text-sm font-semibold"
                      >
                        <IconMinus size={14} />
                      </button>
                      <div className="font-mono text-xl">{timerMinutes.toString().padStart(2, '0')}</div>
                      <button
                        onClick={() => adjustTimerMinutes(1)}
                        className="bg-gray-700 hover:bg-gray-600 text-white py-0.5 px-1 rounded-sm shadow-md transition-colors duration-200 text-sm font-semibold"
                      >
                        <IconPlus size={14} />
                      </button>
                    </div>
                  </div>

                  <div className="text-3xl font-bold text-gray-400 mx-0.5">:</div> {/* Reduced mx to mx-0.5 */}

                  {/* Seconds Adjusters */}
                  <div className="flex flex-col items-center">
                    <div className="text-xs font-medium text-gray-300 mb-0.5">Sec</div>
                    <div className="flex items-center gap-0.5"> {/* Gap for buttons and number */}
                      <button
                        onClick={() => adjustTimerSeconds(-1)}
                        className="bg-gray-700 hover:bg-gray-600 text-white py-0.5 px-1 rounded-sm shadow-md transition-colors duration-200 text-sm font-semibold"
                      >
                        <IconMinus size={14} />
                      </button>
                      <div className="font-mono text-xl">{timerSeconds.toString().padStart(2, '0')}</div>
                      <button
                        onClick={() => adjustTimerSeconds(1)}
                        className="bg-gray-700 hover:bg-gray-600 text-white py-0.5 px-1 rounded-sm shadow-md transition-colors duration-200 text-sm font-semibold"
                      >
                        <IconPlus size={14} />
                      </button>
                    </div>
                  </div>
                </div>
              )}
              
              <div className="flex justify-center gap-2 mb-4">
                <button
                  onClick={isRunning ? handlePause : handleStart}
                  disabled={!isRunning && timerMinutes === 0 && timerSeconds === 0 && timeLeft === 0}
                  className={`flex-1 min-w-[80px] py-1.5 px-2.5 rounded-lg shadow-md transition-all duration-200 text-sm font-semibold disabled:opacity-50 disabled:cursor-not-allowed ${
                    isRunning ? 'bg-red-600 hover:bg-red-700' : 'bg-green-600 hover:bg-green-700'
                  }`}
                >
                  {isRunning ? <IconPause className="inline-block mr-1" size={18} /> : <IconPlay className="inline-block mr-1" size={18} />}
                  {isRunning ? 'Pause' : 'Start'}
                </button>
                
                <button
                  onClick={handleReset}
                  className="flex-1 min-w-[80px] bg-blue-600 hover:bg-blue-700 text-white py-1.5 px-2.5 rounded-lg shadow-md transition-all duration-200 text-sm font-semibold"
                >
                  <IconRotateCcw className="inline-block mr-1" size={18} />
                  Reset
                </button>
              </div>

              {timerFinished && (
                <div className="text-red-400 font-bold animate-pulse mt-2">Time's Up!</div>
              )}
            </div>
          );
        };

        // Main App component that houses both Stopwatch and Timer
        const App = () => {
          const [activeTab, setActiveTab] = useState('stopwatch'); // 'stopwatch' or 'timer'
          const containerRef = useRef(null); // Ref for the outer container to measure its width
          const [scaleFactor, setScaleFactor] = useState(1); // State to control the scaling of content

          useEffect(() => {
            const container = containerRef.current;
            if (!container) return;

            const observer = new ResizeObserver(entries => {
              for (let entry of entries) {
                const currentWidth = entry.contentRect.width;
                const referenceWidth = 320; // The width at which the content is at its default (100%) scale.
                                             // This is a common width for small phones, allowing content to look "normal" here.
                const targetMinimumContentWidth = 200; // The target visual width for the content at its most scaled-down point.

                let newScale = 1; // Default to no scaling

                if (currentWidth < referenceWidth) {
                  // Calculate the scale based on the current width relative to the reference width.
                  newScale = currentWidth / referenceWidth;

                  // Ensure the scale doesn't make the content visually smaller than our target minimum.
                  // This means if the actual container shrinks below 200px, the content will still appear as if it's in a 200px container.
                  newScale = Math.max(newScale, targetMinimumContentWidth / referenceWidth);
                }
                setScaleFactor(newScale);
              }
            });

            observer.observe(container);

            return () => observer.unobserve(container);
          }, []);

          return (
            <div className="min-h-screen bg-gray-900 flex items-center justify-center p-2 sm:p-4 font-inter">
              {/* Main application container - it will receive the ref and define the overall component's responsive width */}
              <div
                ref={containerRef}
                // Removed min-w-[200px] to allow the outer container to shrink freely with the viewport.
                className="bg-gray-800 text-white rounded-xl shadow-2xl w-full max-w-sm flex flex-col items-center justify-center overflow-hidden"
              >
                {/* Inner div that holds all the app's content and will be scaled */}
                <div
                  style={{
                    transform: `scale(${scaleFactor})`,
                    transformOrigin: 'center center',
                    display: 'flex',
                    flexDirection: 'column',
                    alignItems: 'center',
                    justifyContent: 'center',
                    // Removed minWidth and minHeight as transform: scale should handle proportional sizing
                  }}
                  className="relative p-4"
                >
                  {/* Tab Navigation */}
                  <div className="flex w-full mb-4 bg-gray-700 rounded-lg p-1">
                    <button
                      className={`flex-1 py-2 px-4 rounded-md text-sm font-medium transition-colors duration-200 ${
                        activeTab === 'stopwatch' ? 'bg-indigo-600 text-white shadow-md' : 'text-gray-300 hover:bg-gray-600'
                      }`}
                      onClick={() => setActiveTab('stopwatch')}
                    >
                      <IconClock style={{ width: 'clamp(0.75rem, 3vw, 1.5rem)', height: 'clamp(0.75rem, 3vw, 1.5rem)' }} className="mx-auto" />
                      <div style={{ fontSize: 'clamp(0.5rem, 2vw, 0.75rem)', marginTop: 'clamp(0.125rem, 0.5vw, 0.25rem)' }}>Stopwatch</div>
                    </button>
                    <button
                      className={`flex-1 py-2 px-4 rounded-md text-sm font-medium transition-colors duration-200 ${
                        activeTab === 'timer' ? 'bg-indigo-600 text-white shadow-md' : 'text-gray-300 hover:bg-gray-600'
                      }`}
                      onClick={() => setActiveTab('timer')}
                    >
                      <IconTimer style={{ width: 'clamp(0.75rem, 3vw, 1.5rem)', height: 'clamp(0.75rem, 3vw, 1.5rem)' }} className="mx-auto" />
                      <div style={{ fontSize: 'clamp(0.5rem, 2vw, 0.75rem)', marginTop: 'clamp(0.125rem, 0.5vw, 0.25rem)' }}>Timer</div>
                    </button>
                  </div>

                  {/* Conditional Rendering of Stopwatch or Timer */}
                  {activeTab === 'stopwatch' ? <Stopwatch /> : <Timer />}
                </div>
              </div>
            </div>
          );
        };

        // Render the App component into the root div
        ReactDOM.render(<App />, document.getElementById('root'));

        // Service Worker Registration (Removed due to blob: URL protocol restriction)
        // For PWA offline capabilities, service-worker.js would need to be a separate file
        // and registered from a standard HTTP/HTTPS URL.
    </script>
</body>
</html>
